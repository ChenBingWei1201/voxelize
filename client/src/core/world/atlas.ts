import {
  Texture,
  CompressedTexture,
  CanvasTexture,
  ClampToEdgeWrapping,
  NearestFilter,
  MeshBasicMaterial,
  DoubleSide,
  Color,
} from "three";

import { TextureRange } from "./registry";

/**
 * Parameters to create a new {@link TextureAtlas} instance.
 */
export type TextureAtlasParams = {
  /**
   * The number of block textures on each side of the atlas.
   */
  countPerSide: number;

  /**
   * The dimension of each block texture.
   */
  dimension: number;
};

/**
 * A texture atlas is a collection of textures that are packed into a single texture.
 * This is useful for reducing the number of draw calls required to render a scene, since
 * all block textures can be rendered with a single draw call.
 *
 * By default, the texture atlas creates an additional border around each texture to prevent
 * texture bleeding.
 *
 * ![Texture bleeding](/img/texture-bleeding.png)
 *
 */
export class TextureAtlas {
  /**
   * The parameters used to create the texture atlas.
   */
  public params: TextureAtlasParams;

  /**
   * The THREE.JS canvas texture that has been generated.
   */
  public texture: CanvasTexture;

  /**
   * A basic mesh material that can be used to visualize the texture atlas.
   */
  public material: MeshBasicMaterial;

  /**
   * The loaded set of base64 data URIs for each block-face texture.
   */
  public dataURLs: Map<string, string> = new Map();

  /**
   * The canvas that is used to generate the texture atlas.
   */
  public canvas = document.createElement("canvas");

  /**
   * The margin between each block texture in the atlas.
   */
  public margin = 0;

  /**
   * Create a new texture atlas.
   *
   * @param textureMap A map that points a side name to a texture or color.
   * @param ranges The ranges on the texture atlas generated by the server.
   * @param params The parameters used to create the texture atlas.
   * @returns The texture atlas generated.
   */
  static create = (
    textureMap: Map<string, Texture | Color>,
    ranges: Map<string, TextureRange>,
    params: TextureAtlasParams
  ) => {
    const atlas = new TextureAtlas();
    atlas.params = params;

    const { countPerSide, dimension } = params;

    textureMap.forEach((texture, key) => {
      if (!texture) {
        textureMap.set(key, this.makeUnknownTexture(dimension));
      }
    });

    const offset = 1 / (countPerSide * 4);

    let margin = 1;
    let r = (margin / offset / countPerSide - 2 * margin) / dimension;

    while (r !== Math.floor(r)) {
      r *= 2;
      margin *= 2;
    }

    const canvasWidth = (dimension * r + margin * 2) * countPerSide;
    const canvasHeight = (dimension * r + margin * 2) * countPerSide;
    atlas.canvas.width = canvasWidth;
    atlas.canvas.height = canvasHeight;

    const context = atlas.canvas.getContext("2d");
    context.imageSmoothingEnabled = false;

    ranges.forEach((range, textureName) => {
      const { startU, endV } = range;
      const texture = textureMap.get(textureName);

      if (texture instanceof Color) {
        context.fillStyle = `#${texture.getHexString()}`;
        context.fillRect(
          (startU - offset) * canvasWidth,
          (1 - endV - offset) * canvasHeight,
          dimension * r + 2 * margin,
          dimension * r + 2 * margin
        );
        context.fillRect(
          (startU - offset) * canvasWidth + margin,
          (1 - endV - offset) * canvasHeight + margin,
          dimension * r,
          dimension * r
        );
        return;
      }

      if (texture instanceof CompressedTexture) {
        throw new Error("CompressedTextures are not supported.");
      }

      // saving the textures
      if (typeof texture.image.toDataURL === "undefined") {
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = texture.image.naturalWidth;
        tempCanvas.height = texture.image.naturalHeight;
        tempCanvas.getContext("2d")?.drawImage(texture.image, 0, 0);
        atlas.dataURLs.set(textureName, tempCanvas.toDataURL());
      } else {
        atlas.dataURLs.set(textureName, texture.image.toDataURL());
      }

      if (context) {
        // Draw a background first.
        context.drawImage(
          texture.image,
          (startU - offset) * canvasWidth,
          (1 - endV - offset) * canvasHeight,
          dimension * r + 2 * margin,
          dimension * r + 2 * margin
        );

        // Carve out the middle.
        context.clearRect(
          (startU - offset) * canvasWidth + margin,
          (1 - endV - offset) * canvasHeight + margin,
          dimension * r,
          dimension * r
        );

        // Draw the actual texture.
        context.drawImage(
          texture.image,
          (startU - offset) * canvasWidth + margin,
          (1 - endV - offset) * canvasHeight + margin,
          dimension * r,
          dimension * r
        );
      }
    });

    atlas.makeCanvasPowerOfTwo(atlas.canvas);
    atlas.texture = new CanvasTexture(atlas.canvas);
    atlas.texture.wrapS = ClampToEdgeWrapping;
    atlas.texture.wrapT = ClampToEdgeWrapping;
    atlas.texture.minFilter = NearestFilter;
    atlas.texture.magFilter = NearestFilter;
    atlas.texture.generateMipmaps = false;
    atlas.texture.needsUpdate = true;
    atlas.margin = margin / canvasWidth;

    atlas.material = new MeshBasicMaterial({
      map: atlas.texture,
      side: DoubleSide,
    });

    return atlas;
  };

  private makeCanvasPowerOfTwo(canvas?: HTMLCanvasElement | undefined) {
    let setCanvas = false;
    if (!canvas) {
      canvas = this.canvas;
      setCanvas = true;
    }
    const oldWidth = canvas.width;
    const oldHeight = canvas.height;
    const newWidth = Math.pow(2, Math.round(Math.log(oldWidth) / Math.log(2)));
    const newHeight = Math.pow(
      2,
      Math.round(Math.log(oldHeight) / Math.log(2))
    );
    const newCanvas = document.createElement("canvas");
    newCanvas.width = newWidth;
    newCanvas.height = newHeight;
    newCanvas.getContext("2d")?.drawImage(canvas, 0, 0, newWidth, newHeight);
    if (setCanvas) {
      this.canvas = newCanvas;
    }
  }

  private static makeUnknownTexture = (
    dimension: number,
    color1 = "#6A67CE",
    color2 = "#16003B",
    segments = 2
  ) => {
    const tempCanvas = document.createElement("canvas") as HTMLCanvasElement;
    const context = tempCanvas.getContext("2d");
    const blockSize = dimension / segments;

    context.canvas.width = dimension;
    context.canvas.height = dimension;
    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < segments; j++) {
        context.fillStyle =
          (i % 2 === 0 && j % 2 === 1) || (i % 2 === 1 && j % 2 === 0)
            ? color1
            : color2;
        context.fillRect(i * blockSize, j * blockSize, blockSize, blockSize);
      }
    }

    return new CanvasTexture(context ? context.canvas : tempCanvas);
  };
}
